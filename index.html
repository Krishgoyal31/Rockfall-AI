<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rockfall AI - Advanced Geohazard Dashboard</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #0D1117;
            --primary-color: #161B22;
            --secondary-color: #010409;
            --accent-color: #58A6FF;
            --glow-color: rgba(88, 166, 255, 0.5);
            --text-primary: #E6EDF3;
            --text-secondary: #8B949E;
            --card-bg: rgba(22, 27, 34, 0.6);
            --card-border: rgba(255, 255, 255, 0.1);
            --success-color: #3FB950;
            --warning-color: #F7B93E;
            --error-color: #F85149;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background:
                radial-gradient(circle at 15% 25%, var(--glow-color) 0%, transparent 40%),
                radial-gradient(circle at 85% 75%, rgba(110, 88, 255, 0.4) 0%, transparent 40%);
            animation: background-pan 25s linear infinite;
            z-index: -1;
        }

        @keyframes background-pan {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1700px;
            margin: 0 auto;
            padding: 2.5rem;
            opacity: 0;
            animation: fadeIn 1s ease-out forwards;
        }

        @keyframes fadeIn { to { opacity: 1; } }

        .header {
            text-align: center;
            margin-bottom: 4rem;
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 700;
            letter-spacing: -1.5px;
            background: -webkit-linear-gradient(45deg, var(--accent-color), #c3d9ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.25rem;
            color: var(--text-secondary);
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 2.5rem;
            margin-bottom: 2.5rem;
        }

        .card {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 2.5rem;
            border: 1px solid var(--card-border);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            transition: transform 0.4s ease, box-shadow 0.4s ease;
            animation: slideInUp 0.6s ease-out forwards;
            opacity: 0;
            position: relative;
            overflow: hidden;
        }

        .card::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 24px;
            padding: 1px;
            background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0));
            -webkit-mask:
                linear-gradient(#fff 0 0) content-box,
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
        }

        .card:hover {
            transform: translateY(-8px);
            box-shadow: 0 16px 45px 0 rgba(0, 0, 0, 0.4), 0 0 0 1px var(--glow-color);
        }

        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(40px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card-header {
            margin-bottom: 2rem;
            color: var(--text-primary);
            font-size: 1.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .card-header svg {
            margin-right: 0.75rem;
            color: var(--accent-color);
        }

        .file-upload {
            position: relative;
            width: 100%;
            margin-bottom: 1.5rem;
        }

        .file-upload input[type=file] {
            position: absolute;
            height: 0.1px; width: 0.1px;
            opacity: 0; overflow: hidden;
            z-index: -1;
        }

        .file-upload label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            border: 2px dashed var(--card-border);
            border-radius: 16px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            color: var(--text-secondary);
        }

        .file-upload label svg {
            width: 48px; height: 48px;
            margin-bottom: 1rem;
            stroke: var(--accent-color);
            transition: transform 0.3s ease;
        }

        .file-upload label:hover {
            background: rgba(88, 166, 255, 0.05);
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        .file-upload label:hover svg {
            transform: scale(1.1) translateY(-5px);
        }

        .file-upload.has-file label {
            background: rgba(63, 185, 80, 0.1);
            border-color: var(--success-color);
            color: var(--success-color);
        }
        .file-upload.has-file label svg {
            stroke: var(--success-color);
        }

        .file-name {
            font-size: 0.9rem;
            margin-top: 0.5rem;
            color: var(--text-primary);
            word-break: break-all;
        }

        .form-group {
            margin-bottom: 1.75rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 0.9rem 1.2rem;
            background: var(--primary-color);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            font-size: 1rem;
            font-family: 'Poppins', sans-serif;
            color: var(--text-primary);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--glow-color);
        }

        .btn {
            width: 100%;
            padding: 1.1rem;
            background: linear-gradient(90deg, var(--accent-color), #3f84e3);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
         .btn:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3), transparent 40%);
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.5s ease;
        }

        .btn:hover:not(:disabled):before {
            transform: translate(-50%, -50%) scale(1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results-grid {
            /* Set to 3 columns for the top row to fit the new card */
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 2.5rem;
            margin-top: 2.5rem;
        }

        @media (min-width: 1200px) {
            .results-grid {
                 grid-template-columns: 1fr 1fr 1fr;
            }
        }

        /* Ensure the map and feature importance still span full width */
        .results-grid > .card[style*="grid-column: 1 / -1"] {
             grid-column: 1 / -1;
        }

        .chart-container {
            height: 400px;
        }

        /* Styles for the NEW Critical Metrics card */
        .critical-metrics-grid {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .critical-metric-card {
            background: var(--primary-color);
            border-radius: 16px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid var(--card-border);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .critical-metric-value {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }
        .critical-metric-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Original Risk Summary Styles (Ensuring this section looks like cards) */
        .risk-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 2rem;
            margin-bottom: 2.5rem;
        }

        .risk-card {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 1.75rem;
            text-align: center;
            border: 1px solid var(--card-border);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
        }

        .risk-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 25px var(--glow-color);
        }

        .risk-value {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .high-risk { color: var(--error-color); }
        .medium-risk { color: var(--warning-color); }
        .low-risk { color: var(--success-color); }

        /* Styles for the NEW Risk Gauge and Factor Summary */
        .risk-gauge-layout {
            display: grid;
            grid-template-columns: 1fr 1.5fr; /* 1/3 for gauge, 2/3 for summary */
            gap: 2.5rem;
            align-items: center;
            min-height: 250px;
        }

        .gauge-area {
            height: 300px;
            width: 100%;
        }

        .factor-summary-area {
            padding-left: 1.5rem;
            border-left: 1px solid var(--card-border);
        }

        .factor-summary-area h4 {
            color: var(--accent-color);
            margin-bottom: 1rem;
            font-size: 1.25rem;
        }

        .factor-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 10px; /* Space between rows */
        }

        .factor-table th, .factor-table td {
            padding: 0.5rem;
            text-align: left;
        }

        .factor-table th {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--card-border);
        }

        .factor-table td {
            font-weight: 600;
            color: var(--text-primary);
        }

        .impact-high { color: var(--error-color); }
        .impact-medium { color: var(--warning-color); }
        .impact-low { color: var(--success-color); }

        .factor-note {
            margin-top: 1.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
            border-top: 1px solid var(--card-border);
            padding-top: 1rem;
        }

        @media (max-width: 900px) {
            .risk-gauge-layout {
                grid-template-columns: 1fr; /* Stack on smaller screens */
            }
            .factor-summary-area {
                border-left: none;
                padding-left: 0;
                padding-top: 1.5rem;
            }
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.2);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }

        .sample-data {
            margin-top: 2rem;
            padding: 1.25rem;
            background: rgba(88, 166, 255, 0.05);
            border-radius: 12px;
            border-left: 4px solid var(--accent-color);
        }

        .sample-data h4 {
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .download-btn {
            display: inline-block;
            margin-top: 0.75rem;
            padding: 0.6rem 1.2rem;
            background: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background 0.3s ease, transform 0.3s ease;
        }

        .download-btn:hover {
            background: var(--accent-color);
            transform: translateY(-2px);
        }

        /* NEW STYLES for AI Summary */
        #aiSummary {
            background: var(--primary-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            border: 1px solid var(--card-border);
            font-size: 1rem;
            line-height: 1.6;
        }
        #aiSummary h4 {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
        }

        #map {
            height: 100%;
            width: 100%;
            border-radius: 20px;
            min-height: 450px;
        }

        .leaflet-popup-content-wrapper {
            background: var(--primary-color);
            color: var(--text-primary);
            border-radius: 12px;
            border: 1px solid var(--card-border);
        }
        .leaflet-popup-tip { background: var(--primary-color); }
        .leaflet-tile-pane { filter: invert(1) hue-rotate(180deg) brightness(0.8) contrast(1.1); }

        .disclaimer {
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid var(--error-color);
            border-radius: 20px;
            padding: 2rem;
            margin-top: 2.5rem;
            color: var(--text-primary);
        }

        .disclaimer h4 {
            margin-bottom: 0.5rem;
            color: var(--error-color);
            font-size: 1.25rem;
        }

        #dataPreview {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }

        /* FIX: Ensure table cells wrap text or enforce horizontal scroll in data preview */
        #dataPreview > div {
             overflow-x: auto; /* Enable horizontal scrolling */
        }
        #dataPreview table {
            table-layout: auto;
            width: 100%;
            min-width: 700px; /* Enforce minimum width for columns to spread out */
        }
        #dataPreview th, #dataPreview td {
            padding: 10px;
            text-align: left;
            white-space: nowrap; /* Prevent data from wrapping */
            max-width: 120px; /* Ensure columns don't stretch excessively */
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #dataPreview th {
            white-space: normal; /* Allow header names to wrap */
        }
        /* END FIX */

        .toast {
            position: fixed;
            top: 25px;
            right: 25px;
            background: var(--card-bg);
            color: var(--text-primary);
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--card-border);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            align-items: center;
            transform: translateX(120%);
            transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        .toast.show { transform: translateX(0); }
        .toast.success { border-left: 4px solid var(--success-color); }
        .toast.error { border-left: 4px solid var(--error-color); }

        /* --- CHATBOT STYLES START --- */
        #chat-toggle {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: var(--accent-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 20px var(--glow-color);
            transition: all 0.3s ease;
            z-index: 999;
        }
        #chat-toggle:hover {
            transform: scale(1.1);
            background: #79bbff;
        }
        #chat-toggle svg {
            width: 32px;
            height: 32px;
            color: white;
            stroke: white;
        }
        #chat-window {
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 370px;
            max-width: 90vw;
            height: 500px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 24px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 998;
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        #chat-window.open {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }
        .chat-header {
            padding: 1.25rem;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid var(--card-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-header h4 {
            font-weight: 600;
            font-size: 1.1rem;
        }
        .chat-header button {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.5rem;
        }
        .chat-messages {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .chat-message {
            padding: 0.75rem 1rem;
            border-radius: 16px;
            max-width: 80%;
            line-height: 1.5;
            font-size: 0.95rem;
            white-space: pre-wrap; /* Allows text to wrap */
        }
        .chat-message.user {
            background: var(--accent-color);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }
        .chat-message.bot {
            background: var(--primary-color);
            color: var(--text-primary);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }
        .chat-form {
            display: flex;
            padding: 1rem;
            border-top: 1px solid var(--card-border);
            background: rgba(0,0,0,0.2);
        }
        .chat-form input {
            flex-grow: 1;
            background: var(--secondary-color);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            font-family: 'Poppins', sans-serif;
            font-size: 1rem;
        }
        .chat-form input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--glow-color);
        }
        .chat-form button {
            background: var(--accent-color);
            border: none;
            border-radius: 12px;
            padding: 0 1rem;
            margin-left: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }
        .chat-form button:hover { background: #79bbff; }
        .chat-form button svg {
            color: white;
            stroke: white;
            width: 20px;
        }
        /* --- CHATBOT STYLES END --- */
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Rockfall AI</h1>
            <p>Advanced Predictive Geohazard Risk Assessment</p>
        </header>

        <main class="dashboard-grid">
            <section class="card" style="animation-delay: 0.1s;">
                <h3 class="card-header">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22h6a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v5"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M4.268 18.182a2.828 2.828 0 1 0 4-4L14 8l-4.243-4.243a2.829 2.829 0 1 0-4 4Z"/></svg>
                    Configuration
                </h3>

                <div class="file-upload" id="csvUpload">
                    <input type="file" id="csvFile" accept=".csv" />
                    <label for="csvFile">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                        <span>Upload Time-Series CSV</span>
                        <small>Must include 'timestamp' column</small>
                        <span class="file-name" id="csvFileName"></span>
                    </label>
                </div>

                 <div class="file-upload" id="demUpload">
                    <input type="file" id="demFile" accept=".tif,.tiff,.png,.jpg,.jpeg" />
                    <label for="demFile">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l8.57-8.57A4 4 0 1 1 18 8.84l-8.59 8.59a2 2 0 0 1-2.83-2.83l.79-.79"></path></svg>
                        <span>Upload DEM/Image (Optional)</span>
                        <small>GeoTIFF, PNG, or JPG</small>
                        <span class="file-name" id="demFileName"></span>
                    </label>
                </div>

                <div class="form-group">
                    <label for="horizonHours">Prediction Horizon (hours)</label>
                    <input type="number" id="horizonHours" value="24" min="1" max="168" />
                </div>

                <div class="form-group">
                    <label for="modelType">Prediction Model</label>
                    <select id="modelType">
                        <option value="xgboost">XGBoost Classifier</option>
                        <option value="isolation">Isolation Forest (Anomaly)</option>
                        <option value="heuristic">Heuristic Rules</option>
                    </select>
                </div>

                <button class="btn" id="runPrediction" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"/><path d="M7.07 14.94c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3"/><path d="M12.06 12.03 12 12l.06-.03M4.01 4.01 4 4l.01.01"/></svg>
                    Run Prediction
                </button>

                <div class="sample-data">
                    <h4>Need an example?</h4>
                    <p>Download our sample dataset to get started.</p>
                    <a href="#" class="download-btn" id="downloadSample">Download Sample CSV</a>
                </div>
            </section>

            <section class="card" style="animation-delay: 0.2s;">
                <h3 class="card-header">
                     <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></svg>
                    Data Preview
                </h3>
                <div id="dataPreview">
                    <p style="color: var(--text-secondary); text-align: center;">
                        Upload a CSV file to see a preview of your data
                    </p>
                </div>
            </section>
        </main>

        <section id="results" style="display: none;">
            <div class="risk-summary">
                <div class="risk-card" style="animation-delay: 0.1s;"><div class="risk-value high-risk" id="maxRisk">0%</div><div class="risk-label">Maximum Risk</div></div>
                <div class="risk-card" style="animation-delay: 0.2s;"><div class="risk-value medium-risk" id="avgRisk">0%</div><div class="risk-label">Average Risk</div></div>
                <div class="risk-card" style="animation-delay: 0.3s;"><div class="risk-value low-risk" id="totalRows">0</div><div class="risk-label">Total Predictions</div></div>
                <div class="risk-card" style="animation-delay: 0.4s;"><div class="risk-value high-risk" id="highRiskCount">0</div><div class="risk-label">High Risk Events</div></div>
            </div>

            <div class="results-grid">
                <div class="card" style="animation-delay: 0.5s;"><h3 class="card-header">Risk Timeline</h3><div id="timelineChart" class="chart-container"></div></div>

                <div class="card" style="animation-delay: 0.6s;"><h3 class="card-header">Risk Density Over Time</h3><div id="densityChart" class="chart-container"></div></div>

                <div class="card" style="animation-delay: 0.65s;">
                    <h3 class="card-header">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v20"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>
                        Critical Metrics
                    </h3>
                    <div class="critical-metrics-grid">
                        <div class="critical-metric-card" style="animation-delay: 0.1s;">
                            <div class="critical-metric-value low-risk" id="currentRisk">N/A</div>
                            <div class="critical-metric-label">Latest Risk Probability</div>
                        </div>
                        <div class="critical-metric-card" style="animation-delay: 0.2s;">
                            <div class="critical-metric-value" id="nextHighRiskTime" style="font-size: 1.5rem; color: var(--text-primary); margin: 0.6rem 0;">Processing...</div>
                            <div class="critical-metric-label">Next High Risk Window</div>
                        </div>
                        <div class="critical-metric-card" style="animation-delay: 0.3s;">
                            <div class="critical-metric-value" id="maxDisplacement">0 mm</div>
                            <div class="critical-metric-label">Max Predicted Displacement</div>
                        </div>
                    </div>
                </div>

                <div class="card" style="grid-column: 1 / -1; animation-delay: 0.7s;"><h3 class="card-header">Spatial Risk Map</h3><div id="map"></div></div>

                <div class="card" style="grid-column: 1 / -1; animation-delay: 0.8s;">
                    <h3 class="card-header">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16.5v-4.5"/><path d="M12 7.5v1.5"/></svg>
                        Overall Risk Index & Key Factors
                    </h3>
                    <div id="riskGaugeContainer" class="risk-gauge-layout">
                        <div id="gaugePlot" class="gauge-area">
                            </div>
                        <div id="factorSummary" class="factor-summary-area">
                            <h4>Top Predictive Factors:</h4>
                            <table class="factor-table">
                                <thead>
                                    <tr><th>Factor</th><th>Importance</th><th>Impact</th></tr>
                                </thead>
                                <tbody id="factorTableBody">
                                    </tbody>
                            </table>
                            <p class="factor-note">The index above represents the average rockfall risk across the entire predicted horizon.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card" style="margin-top: 2.5rem; animation-delay: 0.9s;">
                <h3 class="card-header">Download Results</h3>
                <div id="aiSummary">
                    <p style="color: var(--text-secondary);">Your AI-generated executive summary will appear here once a prediction is run.</p>
                </div>
                <button class="btn" id="downloadResults" style="margin-top: 1.5rem; max-width: 350px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    Download Predictions CSV
                </button>
            </div>
        </section>

        <footer class="disclaimer" style="animation-delay: 1s;">
            <h4>Important Disclaimer</h4>
            <p>This software provides decision-support predictions only and is not a substitute for professional engineering judgment, field monitoring, or established safety procedures. Always consult with qualified geotechnical engineers and follow local safety protocols when making critical decisions about rockfall hazards.</p>
        </footer>
    </div>

    <div id="chat-toggle">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 21 1.65-3.8a9 9 0 1 1 3.4 2.9l-5.05.9"/>
        <path d="M9 10a.5.5 0 0 0 1 0V9a.5.5 0 0 0-1 0v1Zm0 0a5 5 0 0 0 5 5h1a.5.5 0 0 0 0-1h-1a4 4 0 0 1-4-4v-1a.5.5 0 0 0-1 0v1Z"/></svg>
    </div>
    <div id="chat-window">
        <div class="chat-header">
            <h4>Rockfall AI Assistant</h4>
            <button id="chat-close-btn">&times;</button>
        </div>
        <div class="chat-messages" id="chat-messages">
            </div>
        <form class="chat-form" id="chat-form">
            <input type="text" id="chat-input" placeholder="Ask for precautions..." autocomplete="off">
            <button type="submit">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
            </button>
        </form>
    </div>

    <script>
        // ##################################################################
        // #                            CONFIG                            #
        // ##################################################################
        const OLLAMA_API_URL = 'http://localhost:11434/api/generate';
        const OLLAMA_MODEL = 'llama3.2';

        // Global state
        let uploadedData = null;
        let predictionResults = null;
        let map = null;

        const DOM = {
            csvFile: document.getElementById('csvFile'),
            demFile: document.getElementById('demFile'),
            csvUpload: document.getElementById('csvUpload'),
            demUpload: document.getElementById('demUpload'),
            csvFileName: document.getElementById('csvFileName'),
            demFileName: document.getElementById('demFileName'),
            runPredictionBtn: document.getElementById('runPrediction'),
            downloadSampleBtn: document.getElementById('downloadSample'),
            downloadResultsBtn: document.getElementById('downloadResults'),
            dataPreview: document.getElementById('dataPreview'),
            resultsSection: document.getElementById('results'),
            maxRisk: document.getElementById('maxRisk'),
            avgRisk: document.getElementById('avgRisk'),
            totalRows: document.getElementById('totalRows'),
            highRiskCount: document.getElementById('highRiskCount'),
            modelType: document.getElementById('modelType'),
            horizonHours: document.getElementById('horizonHours'),
            chatToggle: document.getElementById('chat-toggle'),
            chatWindow: document.getElementById('chat-window'),
            chatCloseBtn: document.getElementById('chat-close-btn'),
            chatMessages: document.getElementById('chat-messages'),
            chatForm: document.getElementById('chat-form'),
            chatInput: document.getElementById('chat-input'),

            // --- NEW ELEMENTS FOR CRITICAL METRICS CARD ---
            currentRisk: document.getElementById('currentRisk'),
            nextHighRiskTime: document.getElementById('nextHighRiskTime'),
            maxDisplacement: document.getElementById('maxDisplacement'),
            factorTableBody: document.getElementById('factorTableBody'),

            // --- NEW ELEMENT FOR AI SUMMARY ---
            aiSummary: document.getElementById('aiSummary'),

            // --- NEW ELEMENT FOR DENSITY CHART ---
            densityChart: document.getElementById('densityChart'), // Corrected DOM ID
        };

        const PLOTLY_LAYOUT_CONFIG = {
            font: { color: 'var(--text-primary)' },
            paper_bgcolor: 'transparent',
            plot_bgcolor: 'rgba(1, 4, 9, 0.4)',
            xaxis: {
                gridcolor: 'rgba(255, 255, 255, 0.1)',
                linecolor: 'rgba(255, 255, 255, 0.2)'
            },
            yaxis: {
                gridcolor: 'rgba(255, 255, 255, 0.1)',
                linecolor: 'rgba(255, 255, 255, 0.2)'
            },
            margin: { t: 20, r: 20, b: 50, l: 60 },
            legend: {
                orientation: 'h',
                yanchor: 'bottom',
                y: 1.02,
                xanchor: 'right',
                x: 1
            }
        };

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            generateSampleData();
            DOM.csvFile.addEventListener('change', handleCSVUpload);
            DOM.demFile.addEventListener('change', handleDEMUpload);
            DOM.runPredictionBtn.addEventListener('click', runPrediction);
            DOM.downloadSampleBtn.addEventListener('click', downloadSampleData);
            DOM.downloadResultsBtn.addEventListener('click', downloadResults);
            DOM.chatToggle.addEventListener('click', toggleChatWindow);
            DOM.chatCloseBtn.addEventListener('click', toggleChatWindow);
            DOM.chatForm.addEventListener('submit', handleUserMessage);
        });

        // --- Dashboard Handlers ---
        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.size > 10 * 1024 * 1024) {
                showToast('File size too large (max 10MB).', 'error');
                return;
            }
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const csv = e.target.result;
                    uploadedData = parseCSV(csv);
                    validateCSVStructure(uploadedData);
                    updateDataPreview(uploadedData);
                    DOM.runPredictionBtn.disabled = false;
                    DOM.csvUpload.classList.add('has-file');
                    DOM.csvFileName.textContent = file.name;
                    showToast('CSV file uploaded successfully!', 'success');
                } catch (error) {
                    showToast(`Error parsing CSV: ${error.message}`, 'error');
                    DOM.csvUpload.classList.remove('has-file');
                    DOM.runPredictionBtn.disabled = true;
                    DOM.csvFileName.textContent = '';
                }
            };
            reader.onerror = () => showToast('Error reading file.', 'error');
            reader.readAsText(file);
        }

        function handleDEMUpload(event) {
            const file = event.target.files[0];
            if(file) {
                 DOM.demUpload.classList.add('has-file');
                 DOM.demFileName.textContent = file.name;
                 showToast('DEM/Image uploaded.', 'success');
            }
        }

        async function runPrediction() {
            if (!uploadedData) {
                showToast('Please upload a CSV file first.', 'error');
                return;
            }
            setLoadingState(true);

            try {
                const modelType = DOM.modelType.value;
                const horizon = parseInt(DOM.horizonHours.value);

                // Ensure data columns are converted to numbers for API payload consistency
                const numericData = uploadedData.data.map(row => {
                    const newRow = { ...row };
                    for (const key in newRow) {
                        if (key !== 'timestamp' && key !== 'location_id' && key !== 'lat' && key !== 'lon') {
                             // Use parseFloat and handle potential non-numeric input gracefully
                             newRow[key] = parseFloat(newRow[key].replace(/[^0-9.-]/g, '')) || 0;
                        }
                    }
                    return newRow;
                });

                const payload = {
                    data: numericData,
                    model_type: modelType,
                    horizon: horizon
                };

                const response = await fetch('http://localhost:5001/predict', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `API request failed`);
                }

                const backendResults = await response.json();

                const predictionsWithRisk = uploadedData.data.map((row, index) => {
                    const riskProb = backendResults.risk_probability[index];
                    return {
                        ...row,
                        timestamp: new Date(row.timestamp),
                        risk_prob: riskProb,
                        risk_class: riskProb > 0.15 ? 'High' : riskProb > 0.05 ? 'Medium' : 'Low'
                    };
                });

                predictionResults = {
                    predictions: predictionsWithRisk,
                    summary: {
                        total: predictionsWithRisk.length,
                        maxRisk: Math.max(...predictionsWithRisk.map(p => p.risk_prob)),
                        avgRisk: predictionsWithRisk.reduce((s, p) => s + p.risk_prob, 0) / predictionsWithRisk.length,
                        highRiskCount: predictionsWithRisk.filter(p => p.risk_class === 'High').length,
                        mediumRiskCount: predictionsWithRisk.filter(p => p.risk_class === 'Medium').length,
                        lowRiskCount: predictionsWithRisk.filter(p => p.risk_class === 'Low').length
                    },
                    featureImportances: backendResults.feature_importances,
                    featureNames: backendResults.feature_names
                };

                displayResults(predictionResults);
                showToast('Prediction complete!', 'success');

            } catch (error) {
                showToast(`Prediction failed: ${error.message}`, 'error');
                console.error("Prediction Error:", error);
            } finally {
                setLoadingState(false);
            }
        }

        // --- Data Processing & Validation ---
        function parseCSV(csv) {
            const lines = csv.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            return {
                headers,
                data: lines.slice(1).map(line => {
                    const values = line.split(',');
                    return headers.reduce((obj, header, index) => {
                        obj[header] = values[index]?.trim();
                        return obj;
                    }, {});
                })
            };
        }

        function validateCSVStructure(data) {
            if (!data.headers.includes('timestamp')) {
                throw new Error('CSV must include a "timestamp" column.');
            }
            if (data.data.length > 0 && isNaN(new Date(data.data[0].timestamp).getTime())) {
                 throw new Error('Invalid timestamp format. Use ISO format (e.g., 2024-01-01T12:00:00).');
            }
        }

        // --- UI Updates & Rendering ---
        function setLoadingState(isLoading) {
            const btn = DOM.runPredictionBtn;
            if (isLoading) {
                btn.disabled = true;
                btn.innerHTML = '<div class="spinner"></div>';
            } else {
                btn.disabled = false;
                btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"/><path d="M7.07 14.94c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3"/><path d="M12.06 12.03 12 12l.06-.03M4.01 4.01 4 4l.01.01"/></svg> Run Prediction';
            }
        }

        function updateDataPreview({ headers, data }) {
            // FIX: Change slice limit from 15 to 22
            const PREVIEW_COUNT = 22;
            const previewData = data.slice(0, PREVIEW_COUNT);
            // END FIX

            DOM.dataPreview.innerHTML = `
                <div style="overflow-x: auto; width: 100%;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem; table-layout: auto; min-width: 700px;">
                        <thead><tr style="border-bottom: 1px solid var(--card-border);">
                            ${headers.map(h => `<th style="padding: 10px; text-align: left; font-weight: 500; color: var(--text-secondary); white-space: normal; max-width: 120px;">${h}</th>`).join('')}
                        </tr></thead>
                        <tbody>${previewData.map(row => `<tr>
                            ${headers.map(h => `<td style="padding: 10px; white-space: nowrap; max-width: 120px; overflow: hidden; text-overflow: ellipsis;">${row[h] || ''}</td>`).join('')}
                        </tr>`).join('')}</tbody>
                    </table>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 1.5rem; text-align: center;">Showing first ${PREVIEW_COUNT} of ${data.length} records</p>
                </div>`; // FIX: Updated descriptive text
        }

        // --- NEW HELPER FUNCTION: Find the next time the risk exceeds a threshold (0.15 for High)
        function findNextHighRiskTime(predictions) {
            // Risk classes: High > 0.15
            const highRiskEvent = predictions.find(p => p.risk_prob > 0.15);

            if (highRiskEvent) {
                const date = highRiskEvent.timestamp;
                // Format the time nicely
                const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const dateString = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                return `${timeString} on ${dateString}`;
            }
            return 'None Predicted';
        }

        // --- NEW FUNCTION: Plotly Gauge Chart for Average Risk ---
        function createRiskGauge(avgRisk) {
            const riskPercent = Math.round(avgRisk * 100);

            let needleColor = 'var(--success-color)';
            if (riskPercent > 50) needleColor = 'var(--warning-color)';
            if (riskPercent > 75) needleColor = 'var(--error-color)';

            const data = [{
                type: 'indicator',
                mode: 'gauge+number+delta',
                value: avgRisk, // Use probability (0-1) for gauge
                title: { text: 'Average Predicted Risk' },
                gauge: {
                    axis: { range: [0, 1.0], tickvals: [0, 0.2, 0.5, 0.8, 1.0], ticktext: ['Low', '20%', '50%', '80%', '100%'], threshold: { line: { color: 'var(--error-color)', width: 2 }, thickness: 0.75, value: 0.8 } },
                    bar: { color: 'var(--text-primary)', thickness: 0.1 },
                    bgcolor: 'var(--primary-color)',
                    steps: [
                        { range: [0, 0.25], color: 'rgba(63, 185, 80, 0.4)' },      // Low (Green)
                        { range: [0.25, 0.55], color: 'rgba(247, 185, 62, 0.4)' },   // Medium (Yellow)
                        { range: [0.55, 1.0], color: 'rgba(248, 81, 73, 0.4)' }    // High (Red)
                    ],
                    // Custom needle/pointer
                    threshold: {
                        line: { color: needleColor, width: 2 },
                        thickness: 1,
                        value: avgRisk
                    }
                },
                number: {
                    suffix: "%",
                    value: (avgRisk * 100).toFixed(2), // FIX: Show percentage with two decimal places
                    font: { size: 48, color: needleColor }
                }
            }];

            const layout = {
                ...PLOTLY_LAYOUT_CONFIG,
                margin: { l: 20, r: 20, t: 70, b: 20 },
                height: 300,
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent',
                font: { color: 'var(--text-primary)' }
            };

            Plotly.newPlot('gaugePlot', data, layout, { responsive: true, displayModeBar: false });
        }


        // --- MODIFIED FUNCTION: Populates the Factor Summary Table (Now uses backend data directly) ---
        function createImportanceChart(importances, featureNames) {

            // --- FIX: Trust the backend's provided importances (dynamic heuristic or XGBoost) ---
            const currentImportances = importances;
            const totalImportance = currentImportances.reduce((sum, val) => sum + val, 0);

            // Prepare data, sort descending
            const featuresData = featureNames.map((name, index) => ({
                name: name.replace(/_/g, ' ').replace(/(^\w{1})|(\s+\w{1})/g, letter => letter.toUpperCase()),
                importance: currentImportances[index]
            })).sort((a, b) => b.importance - a.importance);

            // Clear previous content
            DOM.factorTableBody.innerHTML = '';

            // Populate the table with the top features
            featuresData.slice(0, 4).forEach(f => {
                // Handle cases where totalImportance is zero to avoid NaN in percentage
                const normalized = (totalImportance === 0) ? 0 : f.importance / totalImportance;

                // Determine visual impact based on normalized importance score
                let impactClass = 'impact-low';
                let impactText = 'LOW';
                if (normalized > 0.45) { impactClass = 'impact-high'; impactText = 'HIGH'; }
                else if (normalized > 0.3) { impactClass = 'impact-medium'; impactText = 'MEDIUM'; }

                const row = DOM.factorTableBody.insertRow();
                row.innerHTML = `
                    <td>${f.name}</td>
                    <td>${(normalized * 100).toFixed(1)}%</td>
                    <td class="${impactClass}">${impactText}</td>
                `;
            });
        }


        function displayResults({ predictions, summary, featureImportances, featureNames }) {
            // --- Update Main Risk Summary (Restored to original structure) ---
            DOM.maxRisk.textContent = `${(summary.maxRisk * 100).toFixed(1)}%`;
            DOM.avgRisk.textContent = `${(summary.avgRisk * 100).toFixed(1)}%`;
            DOM.totalRows.textContent = summary.total;
            DOM.highRiskCount.textContent = summary.highRiskCount;

            // --- POPULATE NEW CRITICAL METRICS CARD ---
            if (predictions.length > 0) {
                const latestPrediction = predictions[predictions.length - 1];
                const latestRiskProb = latestPrediction.risk_prob;

                // Latest Risk Probability
                DOM.currentRisk.textContent = `${(latestRiskProb * 100).toFixed(1)}%`;
                let riskClass = latestRiskProb > 0.15 ? 'high' : latestRiskProb > 0.05 ? 'medium' : 'low';
                // Note: Class name must match CSS: high-risk, medium-risk, low-risk
                DOM.currentRisk.className = `critical-metric-value ${riskClass}-risk`;

                // Next High Risk Window
                DOM.nextHighRiskTime.textContent = findNextHighRiskTime(predictions);

                // Max Displacement
                // Assuming 'displacement_mm' is present in the data for prediction
                const displacementValues = predictions.map(p => parseFloat(p.displacement_mm));
                const maxDisp = Math.max(...displacementValues.filter(v => !isNaN(v)));
                DOM.maxDisplacement.textContent = isFinite(maxDisp) ? `${maxDisp.toFixed(1)} mm` : 'N/A';
            } else {
                 DOM.currentRisk.textContent = 'N/A';
                 DOM.nextHighRiskTime.textContent = 'N/A';
                 DOM.maxDisplacement.textContent = 'N/A';
            }
            // --- END CRITICAL METRICS POPULATION ---

            DOM.resultsSection.style.display = 'block';
            DOM.resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Call the new Gauge function
            createRiskGauge(summary.avgRisk);

            // Call the updated function to populate the Feature Importance Table
            createImportanceChart(featureImportances, featureNames);

            // Generate the AI summary
            generateAISummary(summary, featureNames, featureImportances);

            // Other charts
            createTimelineChart(predictions);

            // FIX: Call the updated density chart function with the correct element ID and data
            createDensityChart(predictions);

            createRiskMap(predictions);
        }

        function createTimelineChart(predictions) {
            Plotly.newPlot('timelineChart', [{
                x: predictions.map(p => p.timestamp),
                y: predictions.map(p => p.risk_prob * 100),
                type: 'scatter', mode: 'lines', name: 'Risk Probability',
                line: { color: 'var(--accent-color)', width: 2.5 },
                fill: 'tozeroy', fillcolor: 'rgba(88, 166, 255, 0.1)',
            }], { ...PLOTLY_LAYOUT_CONFIG, yaxis: { ...PLOTLY_LAYOUT_CONFIG.yaxis, title: 'Risk Probability (%)' }}, { responsive: true });
        }

        // --- UPDATED FUNCTION: Create Risk Distribution Density Heatmap ---
        function createDensityChart(predictions) {

            // FIX: Ensure it targets the correct element ID: densityChart
            const targetElement = DOM.densityChart;
            targetElement.innerHTML = ''; // Clear old chart

            const xData = predictions.map(p => p.timestamp);
            const yData = predictions.map(p => p.risk_prob * 100);

            const data = [{
                x: xData,
                y: yData,
                name: 'Risk Event Density',
                type: 'histogram2dcontour',
                colorscale: 'YlGnBu',
                reversescale: true,
                contours: {
                    coloring: 'heatmap'
                },
                hovertemplate: 'Risk: %{y:.1f}%<br>Count: %{z}<extra></extra>'
            }];

            const layout = {
                ...PLOTLY_LAYOUT_CONFIG,
                xaxis: { ...PLOTLY_LAYOUT_CONFIG.xaxis, title: 'Time' },
                yaxis: { ...PLOTLY_LAYOUT_CONFIG.yaxis, title: 'Risk Probability (%)' },
                autosize: true,
                margin: { t: 20, b: 50, l: 50, r: 20 },
                hovermode: 'closest',
            };

            Plotly.newPlot('densityChart', data, layout, { responsive: true, displayModeBar: false });
        }


        function createRiskMap(predictions) {
            if (!predictions || predictions.length === 0) return;

            // Check if the necessary columns exist
            if (!predictions[0].lat || !predictions[0].lon) {
                document.getElementById('map').innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 2rem;">Map data not available. Please ensure your CSV includes 'lat' and 'lon' columns.</p>`;
                return;
            }

            // Calculate the center of the map from the data points
            const latitudes = predictions.map(p => parseFloat(p.lat)).filter(lat => !isNaN(lat));
            const longitudes = predictions.map(p => parseFloat(p.lon)).filter(lon => !isNaN(lon));

            if (latitudes.length === 0) return; // No valid coordinates

            const centerLat = latitudes.reduce((sum, lat) => sum + lat, 0) / latitudes.length;
            const centerLon = longitudes.reduce((sum, lon) => sum + lon, 0) / longitudes.length;
            const center = [centerLat, centerLon];

            // Initialize or update the map
            if (!map) {
                map = L.map('map').setView(center, 10);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            } else {
                map.eachLayer(layer => { if (layer instanceof L.CircleMarker || layer instanceof L.TileLayer) map.removeLayer(layer); });
                 L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
                map.flyTo(center, 10);
            }

            // Plot each point from the data
            predictions.forEach((pred, index) => {
                const lat = parseFloat(pred.lat);
                const lon = parseFloat(pred.lon);

                if (!isNaN(lat) && !isNaN(lon)) {
                    const color = pred.risk_class === 'High' ? 'var(--error-color)' : pred.risk_class === 'Medium' ? 'var(--warning-color)' : 'var(--success-color)';
                    L.circleMarker([lat, lon], { color, fillColor: color, fillOpacity: 0.8, radius: 6 + pred.risk_prob * 10 })
                        .addTo(map)
                        .bindPopup(`<b>Location ${pred.location_id || index + 1}</b><br>Risk: ${(pred.risk_prob * 100).toFixed(1)}% (${pred.risk_class})<br>Time: ${pred.timestamp.toLocaleString()}`);
                }
            });
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 5000);
            }, 5000);
        }

        function generateSampleData() {
            // Added displacement_mm, lat, and lon for the new critical metrics card and map
            window.sampleCSV = `timestamp,location_id,displacement_mm,rain_mm,seismic_energy,lat,lon
2024-01-01T00:00:00,LOC001,12.5,0.0,0.1,46.5197,6.6323
2024-01-01T01:00:00,LOC001,12.7,2.1,0.2,46.5197,6.6323
2024-01-01T02:00:00,LOC001,13.1,5.5,0.3,46.5197,6.6323`;
        }

        function downloadData(content, filename, type) {
            const blob = new Blob([content], { type });
            const a = document.createElement('a');
            a.href = window.URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(a.href);
        }

        function downloadSampleData() {
            downloadData(window.sampleCSV, 'rockfall_sample_data.csv', 'text/csv');
        }

        function downloadResults() {
            if (!predictionResults) {
                showToast('No results to download.', 'error');
                return;
            }
            const headers = Object.keys(predictionResults.predictions[0]);
            const csvContent = [
                headers.join(','),
                ...predictionResults.predictions.map(row =>
                    headers.map(h => (row[h] instanceof Date) ? row[h].toISOString() : (typeof row[h] === 'number' ? row[h].toFixed(4) : row[h])).join(',')
                )
            ].join('\n');
            downloadData(csvContent, `rockfall_predictions_${new Date().toISOString().split('T')[0]}.csv`, 'text/csv');
        }

        async function generateAISummary(summary, featureNames, featureImportances) {
             DOM.aiSummary.innerHTML = `
                <h4>AI-Generated Executive Summary</h4>
                <p>Generating summary... <span class="spinner" style="width:12px; height:12px; border-width:2px; display:inline-block;"></span></p>
             `;

            // Format data for the LLM prompt
            const riskClasses = ['Low', 'Medium', 'High'];
            const riskCounts = [summary.lowRiskCount, summary.mediumRiskCount, summary.highRiskCount];
            const riskDistribution = riskClasses.map((rc, i) => `${rc} Risk: ${riskCounts[i]} events`).join(', ');

            const topFactors = featureNames.map((name, i) => ({
                name: name.replace(/_/g, ' ').replace(/(^\w{1})|(\s+\w{1})/g, letter => letter.toUpperCase()),
                importance: (featureImportances[i] * 100).toFixed(1)
            })).sort((a,b) => b.importance - a.importance).slice(0, 3);
            const topFactorsText = topFactors.map(f => `${f.name} (${f.importance}%)`).join(', ');

            const systemPrompt = `You are a professional geotechnical engineering consultant summarizing a rockfall hazard analysis. Write a concise, one-paragraph executive summary (max 100 words) for a client.
Use the following data:
- Average Risk: ${(summary.avgRisk * 100).toFixed(1)}%
- Total Predictions: ${summary.total}
- High Risk Events: ${summary.highRiskCount}
- Risk Distribution: ${riskDistribution}
- Top 3 Contributing Factors: ${topFactorsText}

The summary should state the overall risk level and mention the primary contributing factors. Keep it formal and informative.`;

            const payload = {
                model: OLLAMA_MODEL,
                prompt: systemPrompt,
                stream: true
            };

            try {
                const response = await fetch(OLLAMA_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Ollama server responded with status: ${response.status}`);
                }

                DOM.aiSummary.innerHTML = `<h4>AI-Generated Executive Summary</h4><p></p>`;
                const summaryParagraph = DOM.aiSummary.querySelector('p');

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullBuffer = '';

                const processStream = async () => {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }

                        fullBuffer += decoder.decode(value, { stream: true });
                        const lines = fullBuffer.split('\n');
                        fullBuffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            try {
                                const parsedLine = JSON.parse(line);
                                if (parsedLine.response) {
                                    summaryParagraph.textContent += parsedLine.response;
                                }
                                if (parsedLine.done) {
                                    return;
                                }
                            } catch (e) {
                                console.error("Failed to parse JSON line from stream:", line, e);
                            }
                        }
                    }
                };

                await processStream();

            } catch (error) {
                console.error("Error calling Ollama API:", error);
                DOM.aiSummary.innerHTML = `<h4>AI-Generated Executive Summary</h4><p style="color:var(--error-color);">Error: Could not connect to the local Ollama server to generate a summary.</p>`;
            }
        }

        // --- CHATBOT SCRIPT START (Modified for robust streaming) ---
        let chatInitialized = false;

        function toggleChatWindow() {
            DOM.chatWindow.classList.toggle('open');
            if (DOM.chatWindow.classList.contains('open') && !chatInitialized) {
                addMessageToChat('Hello! I am the Rockfall AI assistant, powered by local Ollama. Ask me for precautions or suggestions to mitigate rockfall risks.', 'bot');
                chatInitialized = true;
            }
        }

        async function handleUserMessage(event) {
            event.preventDefault();
            const userInput = DOM.chatInput.value.trim();
            if (userInput === '') return;

            addMessageToChat(userInput, 'user');
            DOM.chatInput.value = '';

            const botMessageElement = addMessageToChat('', 'bot');
            botMessageElement.innerHTML = '<span class="spinner" style="width:12px; height:12px; border-width:2px; display:inline-block;"></span>';

            await getBotResponse(userInput, botMessageElement);
        }

        async function queryOllamaExpert(userInput, messageElement) {
            const systemPrompt = `You are a world-class geotechnical engineering and safety expert focused on rockfall and slope stability. The user is interacting with a dashboard that provides 'High', 'Medium', and 'Low' rockfall risk predictions based on time-series data (displacement, rain, seismic activity).

Based *only* on the user's query, provide a concise, safety-focused, and actionable response. If the query asks about general precautions, give a brief, prioritized list. If the query is about a specific technical term (e.g., 'XGBoost'), provide a brief, clear explanation.

Keep your response professional, under 150 words, and use markdown formatting (like **bolding** and bullet points) for readability. User Query: "${userInput}"`;

            const payload = {
                model: OLLAMA_MODEL,
                prompt: systemPrompt,
                stream: true
            };

            try {
                const response = await fetch(OLLAMA_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Ollama server responded with status: ${response.status}`);
                }

                messageElement.textContent = '';

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullBuffer = '';

                const processStream = async () => {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }

                        fullBuffer += decoder.decode(value, { stream: true });
                        const lines = fullBuffer.split('\n');

                        // Keep the last element, as it might be an incomplete JSON object
                        fullBuffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            try {
                                const parsedLine = JSON.parse(line);
                                if (parsedLine.response) {
                                    // Append response and update UI immediately for smooth streaming
                                    messageElement.textContent += parsedLine.response;
                                    DOM.chatMessages.scrollTop = DOM.chatMessages.scrollHeight;
                                }
                                if (parsedLine.done) {
                                    return; // Ollama sends { done: true } when the stream finishes
                                }
                            } catch (e) {
                                // Error parsing JSON, could be a partial chunk. Ignore and wait for next chunk.
                            }
                        }
                    }
                };

                await processStream();


            } catch (error) {
                console.error("Error calling Ollama API:", error);
                messageElement.textContent = "Error: Could not connect to the local Ollama server. Please ensure Ollama is running on your computer and you have pulled a model (e.g., `ollama run llama3.2`).";
            }
        }

        function addMessageToChat(text, sender) {
            const messageElement = document.createElement('div');
            messageElement.className = `chat-message ${sender}`;
            messageElement.textContent = text;
            DOM.chatMessages.appendChild(messageElement);
            DOM.chatMessages.scrollTop = DOM.chatMessages.scrollHeight;
            return messageElement;
        }
        // --- CHATBOT SCRIPT END ---
    </script>
</body>
</html>
